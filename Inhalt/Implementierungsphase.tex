% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

\subsection{Docker-Setup}
\label{sec:Docker-Setup}

Als Image für das aktuellste Typo3 Docker-Setup wurde das Image von Martin Helmich genutzt (https://github.com/martin-helmich/docker-typo3). Ein Docker-Image ist eine Datei, welche aus Anweisungen besteht, welche vollständige und ausführbare Version einer Anwendung erstellt. Diese Anweisungen werden in einer docker-compose.yml Daten gespeichert und dann mit dem Befehl docker-compose up ausgeführt. Nach dem Ausführen des Befehls, wird eine Typo3 Instanz erstellt und gestartet. Abhängig von dem angegebenen Port, kann dann das Typo3 über Localhost aufgerufen werden. Nach dem ausführen der Anweisungen, wird dort der Installations-Screen(siehe Abbildung) von Typo3 angezeigt. Nach dem Installieren, kann ausgewählt werden, ob das Typo3 mit einer leeren Startseite gestartet werden soll, oder weitere Konfigurationen installiert/ausgeführt werden sollen. Um das Skeleton möglichst minimal zu halten, wird das Typo3 mit einer leeren Startseite initialisiert.

\subsection{Ausspielen der Typo3 Daten}
\label{sec:Ausspielen der Typo3 Daten}

Damit die Typo3 Daten im JSON-Format ausgespielt werden, wird die Headless-Extension \linebreak (https://extensions.typo3.org/extension/headless) installiert. Danach muss die Extension zum Template hinzugefügt werden, damit Typo3 weiß, dass es das Template dementsprechend anpassen muss. Typo3 spielt nun die Daten im JSON-Format aus. Das JSON muss noch angepasst werden, damit eine Navigationsstruktur damit abgebildet werden kann. Dafür werden folgende Erweiterungen am Template vorgenommen.

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}
\begin{lstlisting}[language=json,firstnumber=1]
lib.page = JSON
lib.page {
  fields {
    navigation {
      fields {
        main {
          dataProcessing {
            10 = FriendsOfTYPO3\Headless\DataProcessing\MenuProcessor
            10 {              
				       special = categories
				       special.value = 1
				       levels = 7
				       as = main
				       expandAll = 1
				       includeSpacer = 1
				       titleField = nav_title // title	
              	dataProcessing {
                	10 = FriendsOfTYPO3\Headless\DataProcessing\FilesProcessor
                	10 {
                  		references.fieldName = media
                  		as = media
                	}
              	}
                 overwriteMenuLevelConfig {
                  stdWrap.cObject {
                    100 = TEXT
                    100.field = uid
                    100.wrap = ,"uid":|
                  }
                }   
            }
          }
        }
      }      
    }
  }
}
\end{lstlisting}
Durch diese Anpassungen erhält das page Objekt die property navigation. Die Eigenschaft navigation hat wiederrum die Eigenschaft main. Mit der Hilfe des Menuprocessor von der Headless Extension, werden in die main Eigenschaft alle Seiten + Unterseiten geladen, welche der 1. Kategorie zugewiesen werden (special = categories \& special value = 1). Falls Bilder für die Seiten gepflegt sind, werden diese ebenfalls durch den FilesProcessor ausgespielt. Diese werde in dem Skeleton aber nicht verwendet. Dies dient nur zum Nutzen von potentiellen zukünftigen Projekten. Die Anpassungen können sowohl in der Skeleton-Extension stattfinden, als auch im Typo3 Backend.

\subsection{Skeleton-Extension / Layout}
\label{sec:Skeleton-Extension / Layout}
Typo3 ermöglicht es Entwicklern das Typo3 mit eigenen Extensions zu erweitern. Diese Extensions müssen einer bestimmten Struktur folgen, welche von Typo3 vorgegeben ist. Die genaue Form lässt sich in der Typo3 Dokumentation finden. \newline https://docs.typo3.org/m/typo3/reference-coreapi/main/en-us/ExtensionArchitecture/Index.html
\paragraph{Datenmodell:}

Alle Komponenten, die gepflegt werden können, sollen für Desktop, Tablet und Mobile verschiedene Breiten gepflegt bekommen können. Ein Text soll beispielsweise nur ein drittel der Bildschirmbreite auf Desktop haben, aber 50\% auf einem Tablet und die volle Breite auf einem Mobiltelefon. Dafür erhalten alle Elemente drei Felder in der Datenbank:
\begin{lstlisting}[language=json,firstnumber=1]
CREATE TABLE tt_content (
        tx_responsive_mobile int(11) DEFAULT '100' NOT NULL,
        tx_responsive_tablet int(11) DEFAULT '100' NOT NULL,
        tx_responsive_desktop int(11) DEFAULT '100' NOT NULL,
);
\end{lstlisting}
Anpassungen an bestehende Tabellen in der Datenbank werden in der ext\_tables.sql Datei vorgenommen. Diese Datei wird automatisch beim installieren von Extensions ausgelesen und die Anpassungen durchgeführt. Felder, welche als Input für Inhaltselemente dienen, werden in Typo3 in der tt\_content Tabelle gespeichert. Diese Felder müssen noch mit angemessenen Auswahlmöglichkeiten versehen werden und dann allen Elementen zugewiesen werden.
\paragraph{Backend:} Die Inputfelder werden als Selects dargestellt. Die Auswahlmöglichkeiten werden im Code vorgegeben.
\begin{lstlisting}[language=json,firstnumber=1]
"tx_responsive_mobile" => Array (
        "exclude" => 1,
        "label" => 'Mobile',
        "config" => Array (
            'type' => 'select',
            'renderType' => 'selectSingle',
            'items' => [
                ['25%','25'],
                ['33%','33'],
                ['50%','50'],
                ['66%','66'],
                ['75%','75'],
                ['100%','100']
            ],
            'default' => '100',
            'size' => 1,
            'maxitems' => 1,
        )
    ),
\end{lstlisting}
Analog zum oberen Code, werden für Tablet und Desktop ebenfalls Konfigurationen vorgenommen und im Array \$tempColumns gespeichert. Welche Eigenschaften Inputfelder brauchen und welche Optionen es bei den Inputfeldern gibt, lässt sich in der Typo3 Dokumentation(https://docs.typo3.org/m/typo3/\newline reference-tca/main/en-us/Columns/Index.html) nachlesen. Um die Inputfelder nun allen Elementen hinzuzufügen, wird die ExtensionManagementUtility Klasse aus dem Typo3 Core genutzt.
\begin{lstlisting}[language=json,firstnumber=1]
\TYPO3\CMS\Core\Utility\ExtensionManagementUtility::addTCAcolumns("tt_content",$tempColumns,1);
\TYPO3\CMS\Core\Utility\ExtensionManagementUtility::addToAllTCAtypes('tt_content','--div--;Responsive,tx_responsive_mobile,tx_responsive_tablet,tx_responsive_desktop','','after:addToAllTCAtypes');
\end{lstlisting}

Die erste Zeile Code speichert die Inputfelder ab, die zweite Zeile Code, fügt sie allen Inhaltselementen hinzu. --div--;Responsive sorgt dafür, dass diese in einem eigenen Tab mit dem Namen Responsive dargestellt werden. Danach wird aufgelistet werden Inputfelder hinzugefügt werden.

\paragraph{Ausspielen ans Frontend:}

Damit die gepflegten Daten auch ans Frontend ausgespielt werden, muss das Template von Typo3 um diese erweitert werden. Extensions haben dafür im Pfad \newline Configuration->TypoScript die Datei setup.typoscript. Hier können Anpassungen ans Template gepflegt werden, diese Anpassungen werden erst aktiv, wenn man die Extension dem Typo3 Template zuweist.

\begin{lstlisting}[language=json,firstnumber=1]
lib.appearance {
    fields {
        responsive_desktop = TEXT
        responsive_desktop {
            field = tx_responsive_desktop
        }
        responsive_tablet = TEXT ......
    }
}
\end{lstlisting}

Die gepflegten Daten werden nun in der Eigenschaft appearance ausgespielt und können von Nuxt3 ausgelesen werden.

\paragraph{Sections:}
Um die Elemente auf einer Seite in Bereiche auszuteilen, wurde ein komplett neues Inhaltselement erstellt. Dieses wurde als Section bezeichnet. Sections können Hintergrundfarben haben, wodurch Abschnitte im Frontend farblich voneinander getrennt dargestellt werden können. Dafür wurde ebenfalls in der tt\_content Tabelle ein Feld angelegt. In dem Fall mit dem Namen tx\_bal\_column\_color. Damit das neue Inhaltselement in Typo3 genutzt werden kann, muss die tt\_content.php Datei um folgenden Code erweitert werden. \Anhang{tt_content.php} \newline Die Datei lässt sich im Pfad Configuration->TCA->Overrides der Extension finden.

Damit das neue Element auch in der Auswahl von Elementen angezeigt wird, muss das Element noch in der ext\_localconf.php Datei im Root Verzeichnes der Extension hinzugefügt werden.\newline \Anhang{ext_localconf.php} \newline Übersetzungen für den Namen und die Beschreibung der Section wurden in einer .xlf Datei gespflegt.


\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplementierungBenutzeroberflaeche}

\begin{itemize}
	\item Beschreibung der Implementierung der Benutzeroberfläche, falls dies separat zur Implementierung der Geschäftslogik erfolgt (\zB bei \acs{HTML}-Oberflächen und Stylesheets).
	\item \Ggfs Beschreibung des Corporate Designs und dessen Umsetzung in der Anwendung.
	\item Screenshots der Anwendung
\end{itemize}
\paragraph{Nuxt3 aufsetzen um DaisyUI installieren}
Um Nuxt3 nutzen zu können, muss eine aktuelle Version von Node.js auf der Betriebssystem installiert werden. Zum installieren von Nuxt3 und DaisyUI wurde der Node Package Manager genutzt.

\paragraph{Dynamische Seiten}
Alle Seiten der Nuxt3 Anwendungen befinden sich im pages Ordner. Da Nuxt3 nicht weiß, wie der Seitenbaum von Typo3 aussieht und dieser sich ständig ändert, können die einzelnen Seiten nicht per Hand eingepflegt werden. Damit Nuxt3 trotzdem weiß welcher Code bei den unterschiedlichen Seiten ausgeführt werden soll, gibt es eine Catch-all Route. Eine Datei/Seite die den Namen [...slug].vue erhält, fungiert als Catch-all Route. Dies bedeutet, dass alle Seiten die nicht gepflegt sind, durch diese Datei verarbeitet werden. Wenn aber beispielsweise eine Shop-Seite angelegt werde soll, die ihre Daten durch eine E-Commerce Platform bekommt. Dann kann im pages Ordner eine shop.vue Datei hinterlegt werden, welche dann für den Pfad beispielseite.de/shop die Daten darstellt. Analog kann dies für alle möglichen Seiten geschehen.

\paragraph{Verarbeitung der Typo3 Daten}

In der nuxt.config.ts Datei können generelle Konfigurationen am Nuxt3 vorgenommen werden. In ihr wurde die URL des Typo3 gespeichert. Dies hat den Vorteil, dass die URL in der Anwendung als Variable genutzt werden kann. Das heißt, dass bei späteren Entwicklungen lediglich die Variable einen anderen Wert bekommen muss und Nuxt automatisch alle Daten von einem anderen Typo3 bezieht.

\begin{lstlisting}[language=json,firstnumber=1]
export default defineNuxtConfig({
    runtimeConfig: {
        public: {
            typo3: 'http://localhost'
        }
    },
})
\end{lstlisting}

Die Variable wird darauf hin in der [...slug].vue Datei genutzt um die Daten vom Typo3 zu laden. Dies geschieht im <script setup> Tag. Nuxt3 Dateien können sowohl einen Script Tag haben, welcher Clientseitig ausgeführt wird, als auch ein Script Tag, welcher Serverseitig ausgeführt wird(hat den Zusatz setup). Da die ladezeit minimal gehalten werden soll, werden die Typo3 Daten hier Serverseitig geladen. Zum Laden der Daten wird die Nuxt3 eigene useAsyncData() Funktion genutzt. Mit ihr können Daten asynchron geladen werden. Zusätzlich hat sie viele Optionen um die Anfrage anzupassen. Eine der Optionen ist es den Cache auszuschalten. Für Entwicklungszwecke wird der Cache hier noch ausgeschaltet. Damit Änderungen im Typo3 direkt sichtbar werden. Wenn das Projekt in Production geht, sollte die Zeile {initialCache: false} entfernt werden. Dadurch Speichert Nuxt3 die Daten im Cache und die Seite wird schnell geladen. Je nach Website kann programmiert werden, dass sich der Cache häufiger oder weniger häufiger leert.

\begin{lstlisting}[language=json,firstnumber=1]
  const runtimeConfig = useRuntimeConfig()
  const route = useRoute();
  const { data } = await useAsyncData(
      "pageData",
    () => $fetch(runtimeConfig.typo3 + route.fullPath),
    {initialCache: false}
  )
\end{lstlisting}

Im route Objekt ist der Pfad der aktuellen Website gespeichert. route.fullPath würde bei der Seite beispielseite.de/beispiel1 dem Wert beispiel1 entsprechen.
Die Daten aus dem Typo3(hier das data Objekt) wurden danach weiter verarbeitet. Der erste Schritt der Datenverarbeitung war es die Daten in Kategorien zu zerlegen. Dafür wurden vier Kategorien/Variablen angelegt. Die Variable breadcrumbs bekam die Daten bezüglich der Breadcrumbs der Seite. Die Variable Content bekam alle Daten bezüglich der Inhaltselemente auf der bestimmten Seite. Die Variable mainNavigation bekam alle Daten der Hauptnavigation. Als letztes bekam die Variable metaData alle Metadaten der Website. Die Breadcrumbs wurden bereits automatisch durch die Headless Extension generiert und sind im Datenobjekt vorhanden. Das gleiche gilt für die Metadaten und dem Großteil der Inhaltselemente. Die Navigationsdaten finden sich in der Eigenschaft main, welche zum Objekt navigation gehört, welches wiederum zum Objekt page gehört. Diese Logik wurde in \ref{sec:Ausspielen der Typo3 Daten} angelegt.

\begin{lstlisting}[language=json,firstnumber=1]
  let breadcrumbs = data.value.breadcrumbs;
  let content = data.value.content.colPos0;
  let mainNavigation = data.value.page.navigation.main;
  let metaData = data.value.meta;
\end{lstlisting}

Mit der Nuxt3 Funktion useHead() können die Metadaten an die Website weiter gegeben werden. Für die Weiterverarbeitung der Breadcrumbs, die Navigation und den Content wurden eigene Komponenten erstellt. Diese erhalten die Variablen als Eigenschaften/Properties/Props zugewiesen. Da Nuxt3 einen automatischen Import von Komponenten hat, müssen diese lediglich im Template gepflegt werden und nicht zusätzlich importiert werden. Dafür wurden die Komponenten im components Ordner gepflegt, damit Nuxt3 diese automatisch importieren kann. Den vollständigen Code der [...slug].vue finden Sie unter \Anhang{[...slug].vue}.

\paragraph{Finale Anwendung}
Screenshots der finalen Anwendung inklusive der gepflegten Dummy-Inhalte der Typo3 Seite befinden sich im \Anhang{Screenshots}.


\subsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}

\begin{itemize}
	\item Beschreibung des Vorgehens bei der Umsetzung/Programmierung der entworfenen Anwendung.
	\item \Ggfs interessante Funktionen/Algorithmen im Detail vorstellen, verwendete Entwurfsmuster zeigen.
	\item Quelltextbeispiele zeigen.
	\item Hinweis: Wie in Kapitel~\ref{sec:Einleitung}: \nameref{sec:Einleitung} zitiert, wird nicht ein lauffähiges Programm bewertet, sondern die Projektdurchführung. Dennoch würde ich immer Quelltextausschnitte zeigen, da sonst Zweifel an der tatsächlichen Leistung des Prüflings aufkommen können.
\end{itemize}

\paragraph{Beispiel}
Die Klasse \texttt{Com\-par\-ed\-Na\-tu\-ral\-Mo\-dule\-In\-for\-ma\-tion} findet sich im \Anhang{app:CNMI}.  
